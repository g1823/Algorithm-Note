#### 问题描述

​	有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？

背包体积：8

| 物品编号 | 体积(vol) | 价值(val) |
| :------: | :-------: | :-------: |
|    1     |     2     |     3     |
|    2     |     3     |     4     |
|    3     |     4     |     5     |
|    4     |     5     |     6     |

#### 蛮力法

​	只需要将所有情况都考虑到，每个物品放与不放的所有组合均计算一边，然后取其中价值最大的情况即可。

现在需要采用合适的方式去表示所有的状态

​	可以想到，数字在内存中存储形式是二进制，可以用数字二进制中为1的位置表示该位置的物品是否放入，比如：

​	1（0000 0001）表示第1个物品放入，其他都不放入；

​	2（0000 0010）表示第2个物品放入，其他都不放入；

​	3（0000 0011）表示第1和第2哥物品放入，其他都不放入。

​	这样4个物品就只需要$$2^4$$这个数字表示，遍历从1到$$2^4$$的所有情况即可。

**时间复杂度分析：**

1. **组合数量**：有 $2^n$种可能的组合。
2. **检查每种组合的时间**：对于每种组合，需要计算组合的总重量和总价值，这需要 $O(n)$的时间。

总的时间复杂度为：$O(n\cdot2^n)$

~~~ java
public static int execute(List<Item> itemList, int maxVolume) {
  int n = itemList.size(), pow = (int) Math.pow(2, n), resultVal = 0, resultIndex = -1;
  // 遍历每一种情况
  for (int i = 1; i < pow; i++) {
    int thisVol = 0, thisVal = 0, tempIndex = i, thisIndex = 0;
    //tempIndex每次右移一位，其中右起第一位与1按位与表示这个物品是否放入
    while (tempIndex > 0) {
      if ((tempIndex & 1) == 1) {
        Item item = itemList.get(thisIndex);
        // 如果当前物品体积加上已经超出，则直接跳出此次循环
        if ((thisVol + item.getVolume()) <= maxVolume) {
          thisVal += item.getValue();
          thisVol += item.getVolume();
        } else {
          break;
        }
      }
      tempIndex = tempIndex >> 1;
      thisIndex++;
    }
    // resultVal：记录最大价值；  resultIndex：记录最大价值对应的情况
    if (thisVal > resultVal) {
      resultVal = thisVal;
      resultIndex = i;
    }
  }
  // 输出最大情况哪些物品放入
  for (int i = 0; resultIndex > 0; i++) {
    if ((resultIndex & 1) == 1) {
      System.out.println("第" + i + 1 + "个物品放入背包");
    }
    resultIndex = resultIndex >> 1;
  }
  return resultVal;
}
class Item {
    int volume;
    int value;
    public Item(int volume, int value) {
        this.volume = volume;
        this.value = value;
    }
    public int getValue() {
        return value;
    }
    public int getVolume() {
        return volume;
    }
}
~~~

#### 动态规划

​	分析上面蛮力法，其实可以发现不同组合之间，出现了大量的重复计算，比如：1111、0111、1011、0011都会计算0011，也就是第一个和第二个物品放入背包的情况。（1011：表示第1、2、4个物品放，第3个不放，从右往左看）

​	这里已经出现了**重复子问题**，可以尝试考虑使用动态规划解决



现在看是否满足最优子结构和无后效性：

​	这里就直接给出解释：比如第n个物品的体积是$$Vol(n)$$，价值为$$Val(n)$$，且背包总体积大于物品的体积。那么对于第n个物品是否放入的最优解，应该在下面二选一：

​	1、不放入，那么当前的最大价值就是前n-1个物品的最大价值

​	2、放入，那么最大价值就应该是在**体积 $$V-Vol(n)$$（保证当前物品能放下）**情况下**前$$n-1$$个物品**的最大价值 + 第n个物品的价值$$Val(n)$$

​	可见，这个是**满足最优子结构**（后面阶段的状态可以由前面阶段的状态推导出来）和**无后效性**（各个子问题的只与它前面的子问题的解相关）的。

**比如：**

已知：

- 在体积为2的情况下，前2个物品的最大价值为3（因为体积为2只能放下物品1）
- 在体积为6的情况下，前2个物品的最大价值为7（物品1和物品2都可以放下）
- 第3个物品的体积为4，价值为5，即$$Vol(3)=4，Val(3)=5$$

现在计算在体积为6($$V=6$$)的情况下，第3($$n=3$$)个物品是否放入的最大价值：

​	首先，$$V=6>Vol(3)=4$$，即当前背包的体积是足以放下第3个物品，那么就需要从下述两种情况中取最大值：

1. 放入物品3：

   为了放入物品3，需要保证背包剩余体积足以放下物品3，也就是需要腾出单位4的体积$$(Vol(3)=4)$$.

   即需要知道体积为2$$(V-Vol(3)=6-4=2)$$的情况下前两个物品的最大价值

   由上面前提可知体积为2的情况下前两个物品的最大价值为3

   然后此时放入物品3，则总价值为8,即$$dp[2,2]+Val(3)=3+5=8$$

   （$$dp[i,j]$$表示体积为j的情况下，前i个物品的最优解）

2. 不放入物品3：

   不放入物品3，那么最大价值自然就是体积为6时，前2个物品的最大价值

   由上面可知为7

其中，8>7，也就是说在体积为6，前3个物品的最大价值为8，即$$dp[3,6]=8$$



根据上面的分析，我们需要记录每种体积下，前n个物品的最优解。那么可以使用一个二维数组$$dp[i, j]$$来表示这个情况：

​	其中i表示前i个物品，j表示体积。

​	那么$$dp[i][j]$$就表示在体积为j的情况下，前i个物品的最优解。

**定义初始状态：**

​	当i=0时，表示没有物体，那么最大价值就应是0，即$$dp[0][ j]=0$$

​	当j=0时，表示体积为0，那么一个物体都放不进去，那么最大价值就应是0，即$$dp[i][0]=0$$

**确定状态转移方程：**

​	$$dp[i,j] = max(  dp[ i-1 ][j]  ,  dp[i-1][j-Vol(i)]) + Val(i))$$

**填表：**

背包体积：8

| 物品编号 | 体积(vol) | 价值(val) |
| :------: | :-------: | :-------: |
|    1     |     2     |     3     |
|    2     |     3     |     4     |
|    3     |     4     |     5     |
|    4     |     5     |     6     |

**1、初始状态**

|  i\j  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| **1** |  0   |      |      |      |      |      |      |      |      |
| **2** |  0   |      |      |      |      |      |      |      |      |
| **3** |  0   |      |      |      |      |      |      |      |      |
| **4** |  0   |      |      |      |      |      |      |      |      |

**2、填写前1个物品行：**（第1个物品：体积为2，价值为3）

a.在体积为1时，也就是$$dp[1][1]$$：

​	此时体积为1，而第一个物品体积为2，放不下，所以$$dp[1][1]=0$$

b.对于体积2~8，也就是$$dp[1][2] — dp[1][8]$$：

​	代入上面状态转移公式，得到$$dp[1][2] =3，dp[1][3]=3,..., dp[1][8] = 3$$

​	也就是说，此时任意体积下，前n-1（前0个）物品的的最大价值都是0，所以最大价值就一定是第一个物品的价值。

|  i\j  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| **1** |  0   |  0   |  3   |  3   |  3   |  3   |  3   |  3   |  3   |
| **2** |  0   |      |      |      |      |      |      |      |      |
| **3** |  0   |      |      |      |      |      |      |      |      |
| **4** |  0   |      |      |      |      |      |      |      |      |

**3、填写前2个物品行：**（第2个物品：体积为3，价值为4）

a.在体积为为1、2时，也就是$$dp[2][1]、dp[2][2]$$：

​	此时体积1或2，而第2个物品体积为3，放不下，所以此时最大价值就是前n-1(1个物品)的最大价值，即$$dp[2][1]=0、dp[2][2]=3$$

b.在体积为3、4时，也就是$$dp[2][3]、dp[2][4]$$:

​	此时体积为3或4，放得下第二个物品，带入上面状态转移公式：

​		不放入第2个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[2][3]=3、dp[2][4]=3$$

​		放入第2个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：

​			$$dp[1][0]+4=4、dp[1][1]+4=4$$					

​	4>3，所以$$dp[2][3]=4$$

​	也就是说，在体积为3的时候，此时放入第2个物品要比单独放入第1个物品价值要大

c.在体积为5~8时,也就是$$dp[2][5] — dp[2][8]$$L

​	此时体积大于等于5，带入状态转移公式：

​		不放入第2个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[1][5—8]=3$$

​		放入第2个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：$$dp[1][5—8]+4=7$$

​	7>3，所以$$dp[2][4]—dp[2][8]=7$$

​	也就是说，在体积大于等于5时，此时可以将前n-1个（第1个）和当前第n个（第2个）都装下。

|  i\j  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| **1** |  0   |  0   |  3   |  3   |  3   |  3   |  3   |  3   |  3   |
| **2** |  0   |  0   |  3   |  4   |  4   |  7   |  7   |  7   |  7   |
| **3** |  0   |      |      |      |      |      |      |      |      |
| **4** |  0   |      |      |      |      |      |      |      |      |

**填写前3个物品行：**（第3个物品：体积为4，价值为5）

a.在体积为1、2、3时，也就是$$dp[3][1—3]$$

​	此时体积小于4，放不下第3个物品，那么最大值就是前n-1个（前2个）物品的最大价值：

​		$$dp[3][1]=0、dp[3][2]=3、dp[3][3]=4$$	

b.在体积为4时。也就是$$dp[3][4]$$

​	此时体积等于4，可以放下第3个物品

​		不放入第3个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[2][4]=4$$

​		放入第3个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：$$dp[2][0]+5=5$$

​	5>4，则$$dp[3][4]=5$$

​	也就是说，在体积为4的情况下，只放入第3个物品，要比不放入第3个物品时，前两个物品的最大价值要高。

c.在体积为5时，也就是$$dp[3][5]$$

​		此时体积为5，放得下第3个物品

​			不放入第3个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[2][5]=7$$

​			放入第3个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：$$dp[2][1]+5=5$$

​	7>5，则$$dp[3][5]=7$$

​	也就是说，在体积为5的情况下，放入第3个物品（导致前两个物品被拿出）要比前两个物品在体积为5的情况下最大价值要低。

d.在体积为6时，也就是$$dp[3][6]$$

​	不放入第3个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[2][6]=7$$

​	放入第3个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：$$dp[2][2]+5=8$$

​	8>7，也就是$$dp[3][6]=8$$

​	也就是说，放入第3个物品（导致前1个物品中第2个被去掉）要比在体积为6的情况下最大价值要高

e.在体积为7、8时，也就是$$dp[3][7]、dp[3][8]$$

​	不放入第3个物品，则最大价值为**当前体积**下**前n-1个**物品的最大价值：$$dp[2][7]=dp[2][8]=7$$

​	放入第3个物品，则最大价值为**当前体积-第n个物品体积**下前n-1个物品的最大价值：

​		$$dp[2][3]+5=9、dp[2][4]+5=9$$

​	9>7，$$dp[3][7]=dp[3][8]=9$$

​	也就是说，在体积为7、8时，放入第3个物品（导致前2个物品中第1个被去掉）要比不放入第3个前两个物品最大价值要高

|  i\j  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| **1** |  0   |  0   |  3   |  3   |  3   |  3   |  3   |  3   |  3   |
| **2** |  0   |  0   |  3   |  4   |  4   |  7   |  7   |  7   |  7   |
| **3** |  0   |  0   |  3   |  4   |  5   |  7   |  8   |  9   |  9   |
| **4** |  0   |      |      |      |      |      |      |      |      |

**填写前4个物品行：**

​	过程与上面类似

|  i\j  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| **1** |  0   |  0   |  3   |  3   |  3   |  3   |  3   |  3   |  3   |
| **2** |  0   |  0   |  3   |  4   |  4   |  7   |  7   |  7   |  7   |
| **3** |  0   |  0   |  3   |  4   |  5   |  7   |  8   |  9   |  9   |
| **4** |  0   |  0   |  3   |  4   |  5   |  7   |  8   |  9   |  10  |

​	最终，得到在体积为8的情况下，4个物品的最优解为$$dp[4][8]=10$$。

**代码：**

~~~ java
/**
* 使用动态规划获得最大的价值
*
* @param itemList  物品
* @param maxVolume 背包最大体积
* @return 最大价值
*/
public static int execute(List<Item> itemList, int maxVolume) {
  // 初始化dp表，第一列初始赋值为0（体积为0什么都放不下），第一行初始赋值为0（没有物品默认为0）。
  int[][] dpTable = new int[itemList.size() + 1][maxVolume + 1];
  int[][] dpTableTrance = new int[itemList.size() + 1][maxVolume + 1];

  // 填表
  for (int i = 1; i < itemList.size() + 1; i++) {
    for (int j = 1; j < maxVolume + 1; j++) {
      // 当前背包体积 < 当前物品体积，即放不下。
      // itemList.get(i - 1) 是因为物品List从下标0开始，不是从1开始
      if (j < itemList.get(i - 1).getVolume()) {
        // 放不下当前物品，那么当前情况下最大价值为 前i-1个物品的在该体积下的最大价值
        dpTable[i][j] = dpTable[i - 1][j];
      } else {
        // 当前背包体积 > 当前物品体积，可以放得下
        // 当前容量下，只有两个选择，放入当前物品，不放入当前物品
        //      不放入当前物品：最大价值为当前体积下前i-1个物品的最大值
        //      放入当前物品：最大价值为前i-1个物品在背包体积为（当前体积-当前物品体积）的最大值
        dpTable[i][j] = Math.max(dpTable[i - 1][j],
                                 dpTable[i - 1][j - itemList.get(i - 1).getVolume()] + itemList.get(i - 1).getValue());
      }
    }
  }
  return dpTable[itemList.size()][maxVolume];
}

class Item {
  int volume;
  int value;
  public Item(int volume, int value) {
    this.volume = volume;
    this.value = value;
  }
  public int getValue() {
    return value;
  }
  public int getVolume() {
    return volume;
  }
~~~

