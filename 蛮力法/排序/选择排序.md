### 分析：

​	每一躺从待排序数据中找出最小（或最大）的元素，然后按照要求放在最后或最前面。

### 过程图解：

- 将待排序数据分区，分为有序区域和无序区域，初始时所有数据均在无序区域。
- 每次从无序区域内找到最大的数，并将其与无序区域最后一个元素替换，然后无序区域范围缩小。
- 不断重复步骤2，直到无序区只剩一个元素，此时排序完成。

**图表实现：**

​	待排序数据：49、27、65、76、38、13

| 序号 | 步骤描述                                                     | 数据变化                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 划分有序区域和无序区域：（方括号括起来的为无序区域）         | [49、27、65、76、38、13]                                     |
| 2    | 第一躺：<br />找出无序区域中最大的数： 76，然后将其放到有序区域<br />即 76 与 13(数组最后的位置)替换位置，并将无序区域缩小 | [49、27、65、**76**、38、**13**] -><br />[49、27、65、**13**、38]、**76** |
| 3    | 第二趟：<br />找出无序区域中最大的数： 65，然后将其放到有序区域<br />即 65 与 38(数组最后的位置)替换位置，并将无序区域缩小 | [49、27、**65**、13、**38**]、76  -><br />[49、27、**38**、13、**65**、76 |
| 4    | 第三趟：<br />找出无序区域中最大的数： 49，然后将其放到有序区域<br />即 49 与 13(数组最后的位置)替换位置，并将无序区域缩小 | [**49**、27、38、**13**]、65、76  -><br />[**13**、27、38]、**49**、65、76 |
| 5    | 第四趟：<br />找出无序区域中最大的数： 38，然后将其放到有序区域<br />即 38 与 38(数组最后的位置)替换位置，并将无序区域缩小 | [13、27、**38**]、49、65、76  -><br />[13、27]、**38**、49、65、76 |
| 6    | 第五趟：<br />找出无序区域中最大的数： 27，然后将其放到有序区域<br />即 27 与 27(数组最后的位置)替换位置，并将无序区域缩小 | [13、**27**]、38、49、65、76  -><br />[13]、27、38、49、65、76 |
| 7    | 无序区域剩余最后一个元素，排序完成。                         | 13、27、38、49、65、76                                       |

### 代码实现：

~~~ java
	public int[] execute(int[] data) {
        for (int i = 0; i < data.length; i++) {
            int maxIndex = 0;
            // 从无序区域内找到最大值的下标
            for (int j = 1; j < data.length - i; j++) {
                maxIndex = data[maxIndex] > data[j] ? maxIndex : j;
            }
            // 并最大值与无序区域最后一个元素替换，然后无序区域范围缩小（通过i++实现）
            int temp = data[maxIndex];
            data[maxIndex] = data[data.length - i - 1];
            data[data.length - i - 1] = temp;
        }
        return data;
    }
~~~



​	



​	

​	





​	

​	

​	



​	

​	

​	 



​	

​	

​	



​	

​	

​	



