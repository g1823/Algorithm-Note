### Brian Kernighan 算法：

​	Brian Kernighan算法是一种高效的位操作技巧，用于计算二进制数中1的个数。这个算法的核心思想是：对于任何非零整数n，执行n与n-1的按位与操作会将n的最低位的1变为0。通过不断重复这个过程，直到n变为0，就可以统计出原始数中1的个数。

#### 1、原理介绍：

~~~
对于数字n，先不关注二进制中第一个1（从右往左数）左边的数，其右边一定都是0
...1000..000
对于数字n-1，相较于n就会变成第一个1变为0，第一个1右侧的所有的0变为1，第一个1左侧的数不变
...0111..111
例如：
1000 = 0111 + 0001
也就是说，n-1相较于n,二进制中第一个1右侧(包括第一个1)的所有数都不相同，左侧相同。
那么 n & (n-1) 就会把n的二进制表示中第一个1改为0.
~~~

![BrianKernighan算法](images/BrianKernighan算法(计算二进制中1的个数)/BrianKernighan算法.svg)

#### 2、应用

##### 338. 比特位计数：

###### 题目描述：

​	给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **1 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

**提示：**

- `0 <= n <= 105`

###### 代码：

~~~ java
    /**
     * Brian Kernighan 算法：
     * 对于任意整数 x，令 x= x & (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。
     * 因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。
     */
    public int[] countBits(int n) {
        int[] result = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            int count = 0;
            int t = i;
            while (t > 0) {
                t = t & (t - 1);
                count++;
            }
            result[i] = count;
        }
        return result;
    }
~~~

##### 461 汉明距离

###### 题目描述：

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

**示例 1：**

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

**示例 2：**

```
输入：x = 3, y = 1
输出：1
```

**提示：**

- `0 <= x, y <= 231 - 1`

###### 代码:

​	首先直接将x和y进行异或操作，得到x和y二进制表示中所有不同的位，这些位的值将为1，相同的则为0.

​	然后使用Brian Kernighan算法计算1的个数即可。

~~~ java
		public int hammingDistance2(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;
            ret++;
        }
        return ret;
    }
~~~

